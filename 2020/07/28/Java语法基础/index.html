<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java 基础 40语言特性 12Q1：Java 语言的优点？① 平台无关性，摆脱硬件束缚，”一次编写，到处运行”。 ② 相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界。 ③ 热点代码检测和运行时编译及优化，使程序随运行时间增长获得更高性能。 ④ 完善的应用程序接口，支持第三方类库。 Q2：Java 如何实现平台无关？JVM： Java 编译器可生成与计算机体系结构无关的字节码指令，字">
<meta property="og:type" content="article">
<meta property="og:title" content="Java语法基础">
<meta property="og:url" content="http://yoursite.com/2020/07/28/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Java 基础 40语言特性 12Q1：Java 语言的优点？① 平台无关性，摆脱硬件束缚，”一次编写，到处运行”。 ② 相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界。 ③ 热点代码检测和运行时编译及优化，使程序随运行时间增长获得更高性能。 ④ 完善的应用程序接口，支持第三方类库。 Q2：Java 如何实现平台无关？JVM： Java 编译器可生成与计算机体系结构无关的字节码指令，字">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-28T14:40:16.487Z">
<meta property="article:modified_time" content="2020-07-28T14:52:32.911Z">
<meta property="article:author" content="liguangyu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/07/28/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java语法基础 | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    

  <a href="https://github.com/liguangyu1995" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/28/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguangyu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java语法基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-28 22:40:16 / 修改时间：22:52:32" itemprop="dateCreated datePublished" datetime="2020-07-28T22:40:16+08:00">2020-07-28</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java-基础-40"><a href="#Java-基础-40" class="headerlink" title="Java 基础 40"></a>Java 基础 40</h1><h2 id="语言特性-12"><a href="#语言特性-12" class="headerlink" title="语言特性 12"></a>语言特性 12</h2><h3 id="Q1：Java-语言的优点？"><a href="#Q1：Java-语言的优点？" class="headerlink" title="Q1：Java 语言的优点？"></a>Q1：Java 语言的优点？</h3><p>① 平台无关性，摆脱硬件束缚，”一次编写，到处运行”。</p>
<p>② 相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界。</p>
<p>③ 热点代码检测和运行时编译及优化，使程序随运行时间增长获得更高性能。</p>
<p>④ 完善的应用程序接口，支持第三方类库。</p>
<h3 id="Q2：Java-如何实现平台无关？"><a href="#Q2：Java-如何实现平台无关？" class="headerlink" title="Q2：Java 如何实现平台无关？"></a>Q2：Java 如何实现平台无关？</h3><p>JVM： Java 编译器可生成与计算机体系结构无关的字节码指令，字节码文件不仅可以轻易地在任何机器上解释执行，还可以动态地转换成本地机器代码，转换是由 JVM 实现的，JVM 是平台相关的，屏蔽了不同操作系统的差异。</p>
<p>语言规范： 基本数据类型大小有明确规定，例如 int 永远为 32 位，而 C/C++ 中可能是 16 位、32 位，也可能是编译器开发商指定的其他大小。Java 中数值类型有固定字节数，二进制数据以固定格式存储和传输，字符串采用标准的 Unicode 格式存储。</p>
<h3 id="Q3：JDK-和-JRE-的区别？"><a href="#Q3：JDK-和-JRE-的区别？" class="headerlink" title="Q3：JDK 和 JRE 的区别？"></a>Q3：JDK 和 JRE 的区别？</h3><p>JDK： Java Development Kit，开发工具包。提供了编译运行 Java 程序的各种工具，包括编译器、JRE 及常用类库，是 JAVA 核心。</p>
<p>JRE： Java Runtime Environment，运行时环境，运行 Java 程序的必要环境，包括 JVM、核心类库、核心配置工具。</p>
<h3 id="Q4：Java-按值调用还是引用调用？"><a href="#Q4：Java-按值调用还是引用调用？" class="headerlink" title="Q4：Java 按值调用还是引用调用？"></a>Q4：Java 按值调用还是引用调用？</h3><p>按值调用指方法接收调用者提供的值，按引用调用指方法接收调用者提供的变量地址。</p>
<p>Java 总是按值调用，方法得到的是所有参数值的副本，传递对象时实际上方法接收的是对象引用的副本。方法不能修改基本数据类型的参数，如果传递了一个 int 值 ，改变值不会影响实参，因为改变的是值的一个副本。</p>
<p>可以改变对象参数的状态，但不能让对象参数引用一个新的对象。如果传递了一个 int 数组，改变数组的内容会影响实参，而改变这个参数的引用并不会让实参引用新的数组对象。</p>
<h3 id="Q5：浅拷贝和深拷贝的区别？"><a href="#Q5：浅拷贝和深拷贝的区别？" class="headerlink" title="Q5：浅拷贝和深拷贝的区别？"></a>Q5：浅拷贝和深拷贝的区别？</h3><p>浅拷贝： 只复制当前对象的基本数据类型及引用变量，没有复制引用变量指向的实际对象。修改克隆对象可能影响原对象，不安全。</p>
<p>深拷贝： 完全拷贝基本数据类型和引用数据类型，安全。</p>
<h3 id="Q6：什么是反射？"><a href="#Q6：什么是反射？" class="headerlink" title="Q6：什么是反射？"></a>Q6：什么是反射？</h3><p>在运行状态中，对于任意一个类都能知道它的所有属性和方法，对于任意一个对象都能调用它的任意方法和属性，这种动态获取信息及调用对象方法的功能称为反射。缺点是破坏了封装性以及泛型约束。反射是框架的核心，Spring 大量使用反射。</p>
<h3 id="Q7：Class-类的作用？如何获取一个-Class-对象？"><a href="#Q7：Class-类的作用？如何获取一个-Class-对象？" class="headerlink" title="Q7：Class 类的作用？如何获取一个 Class 对象？"></a>Q7：Class 类的作用？如何获取一个 Class 对象？</h3><p>在程序运行期间，Java 运行时系统为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类就是 Class，这是一个泛型类。</p>
<p>获取 Class 对象：① 类名.class 。②对象的 getClass方法。③ Class.forName(类的全限定名)。</p>
<h3 id="Q8：什么是注解？什么是元注解？"><a href="#Q8：什么是注解？什么是元注解？" class="headerlink" title="Q8：什么是注解？什么是元注解？"></a>Q8：什么是注解？什么是元注解？</h3><p>注解是一种标记，使类或接口附加额外信息，帮助编译器和 JVM 完成一些特定功能，例如 @Override 标识一个方法是重写方法。</p>
<p>元注解是自定义注解的注解，例如：</p>
<p>@Target：约束作用位置，值是 ElementType 枚举常量，包括 METHOD 方法、VARIABLE 变量、TYPE 类/接口、PARAMETER 方法参数、CONSTRUCTORS 构造方法和 LOACL_VARIABLE 局部变量等。</p>
<p>@Rentention：约束生命周期，值是 RetentionPolicy 枚举常量，包括 SOURCE 源码、CLASS 字节码和 RUNTIME 运行时。</p>
<p>@Documented：表明这个注解应该被 javadoc 记录。</p>
<h3 id="Q9：什么是泛型，有什么作用？"><a href="#Q9：什么是泛型，有什么作用？" class="headerlink" title="Q9：什么是泛型，有什么作用？"></a>Q9：什么是泛型，有什么作用？</h3><p>泛型本质是参数化类型，解决不确定对象具体类型的问题。泛型在定义处只具备执行 Object 方法的能力。</p>
<p>泛型的好处：① 类型安全，放置什么出来就是什么，不存在 ClassCastException。② 提升可读性，编码阶段就显式知道泛型集合、泛型方法等处理的对象类型。③ 代码重用，合并了同类型的处理代码。</p>
<h3 id="Q10：泛型擦除是什么？"><a href="#Q10：泛型擦除是什么？" class="headerlink" title="Q10：泛型擦除是什么？"></a>Q10：泛型擦除是什么？</h3><p>泛型用于编译阶段，编译后的字节码文件不包含泛型类型信息，因为虚拟机没有泛型类型对象，所有对象都属于普通类。例如定义 List<Object> 或 List<String>，在编译后都会变成 List 。</p>
<p>定义一个泛型类型，会自动提供一个对应原始类型，类型变量会被擦除。如果没有限定类型就会替换为 Object，如果有限定类型就会替换为第一个限定类型，例如 &lt;T extends A &amp; B&gt; 会使用 A 类型替换 T。</p>
<h3 id="Q11：JDK8-新特性有哪些？"><a href="#Q11：JDK8-新特性有哪些？" class="headerlink" title="Q11：JDK8 新特性有哪些？"></a>Q11：JDK8 新特性有哪些？</h3><p>lambda 表达式：允许把函数作为参数传递到方法，简化匿名内部类代码。</p>
<p>函数式接口：使用 @FunctionalInterface 标识，有且仅有一个抽象方法，可被隐式转换为 lambda 表达式。</p>
<p>方法引用：可以引用已有类或对象的方法和构造方法，进一步简化 lambda 表达式。</p>
<p>接口：接口可以定义 default 修饰的默认方法，降低了接口升级的复杂性，还可以定义静态方法。</p>
<p>注解：引入重复注解机制，相同注解在同地方可以声明多次。注解作用范围也进行了扩展，可作用于局部变量、泛型、方法异常等。</p>
<p>类型推测：加强了类型推测机制，使代码更加简洁。</p>
<p>Optional 类：处理空指针异常，提高代码可读性。</p>
<p>Stream 类：引入函数式编程风格，提供了很多功能，使代码更加简洁。方法包括 forEach 遍历、count 统计个数、filter 按条件过滤、limit 取前 n 个元素、skip 跳过前 n 个元素、map 映射加工、concat 合并 stream 流等。</p>
<p>日期：增强了日期和时间 API，新的 java.time 包主要包含了处理日期、时间、日期/时间、时区、时刻和时钟等操作。</p>
<p>JavaScript：提供了一个新的 JavaScript 引擎，允许在 JVM上运行特定 JavaScript 应用。</p>
<h3 id="Q12：异常有哪些分类？"><a href="#Q12：异常有哪些分类？" class="headerlink" title="Q12：异常有哪些分类？"></a>Q12：异常有哪些分类？</h3><p>所有异常都是 Throwable 的子类，分为 Error 和 Exception。Error 是 Java 运行时系统的内部错误和资源耗尽错误，例如 StackOverFlowError 和 OutOfMemoryError，这种异常程序无法处理。</p>
<p>Exception 分为受检异常和非受检异常，受检异常需要在代码中显式处理，否则会编译出错，非受检异常是运行时异常，继承自 RuntimeException。</p>
<p>受检异常：① 无能为力型，如字段超长导致的 SQLException。② 力所能及型，如未授权异常 UnAuthorizedException，程序可跳转权限申请页面。常见受检异常还有 FileNotFoundException、ClassNotFoundException、IOException等。</p>
<p>非受检异常：① 可预测异常，例如 IndexOutOfBoundsException、NullPointerException、ClassCastException 等，这类异常应该提前处理。② 需捕捉异常，例如进行 RPC 调用时的远程服务超时，这类异常客户端必须显式处理。③ 可透出异常，指框架或系统产生的且会自行处理的异常，例如 Spring 的 NoSuchRequestHandingMethodException，Spring 会自动完成异常处理，将异常自动映射到合适的状态码。</p>
<h2 id="数据类型-5"><a href="#数据类型-5" class="headerlink" title="数据类型 5"></a>数据类型 5</h2><h3 id="Q1：Java-有哪些基本数据类型？"><a href="#Q1：Java-有哪些基本数据类型？" class="headerlink" title="Q1：Java 有哪些基本数据类型？"></a>Q1：Java 有哪些基本数据类型？</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>内存大小</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1 B</td>
<td>(byte)0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>2 B</td>
<td>(short)0</td>
<td>-2^15^ ~ 2^15^-1</td>
</tr>
<tr>
<td>int</td>
<td>4 B</td>
<td>0</td>
<td>-2^31^ ~ 2^31^-1</td>
</tr>
<tr>
<td>long</td>
<td>8 B</td>
<td>0L</td>
<td>-2^63^ ~ 2^63^-1</td>
</tr>
<tr>
<td>float</td>
<td>4 B</td>
<td>0.0F</td>
<td>±3.4E+38（有效位数 6~7 位）</td>
</tr>
<tr>
<td>double</td>
<td>8 B</td>
<td>0.0D</td>
<td>±1.7E+308（有效位数 15 位）</td>
</tr>
<tr>
<td>char</td>
<td>英文 1B，中文 UTF-8 占 3B，GBK 占 2B。</td>
<td>‘\u0000’</td>
<td>‘\u0000’ ~ ‘\uFFFF’</td>
</tr>
<tr>
<td>boolean</td>
<td>单个变量 4B / 数组 1B</td>
<td>false</td>
<td>true、false</td>
</tr>
<tr>
<td>JVM 没有 boolean 赋值的专用字节码指令，boolean f = false 就是使用 ICONST_0 即常数 0 赋值。单个 boolean 变量用 int 代替，boolean 数组会编码成 byte 数组。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Q2：自动装箱-拆箱是什么？"><a href="#Q2：自动装箱-拆箱是什么？" class="headerlink" title="Q2：自动装箱/拆箱是什么？"></a>Q2：自动装箱/拆箱是什么？</h3><p>每个基本数据类型都对应一个包装类，除了 int 和 char 对应 Integer 和 Character 外，其余基本数据类型的包装类都是首字母大写即可。</p>
<p>自动装箱： 将基本数据类型包装为一个包装类对象，例如向一个泛型为 Integer 的集合添加 int 元素。</p>
<p>自动拆箱： 将一个包装类对象转换为一个基本数据类型，例如将一个包装类对象赋值给一个基本数据类型的变量。</p>
<p>比较两个包装类数值要用 equals ，而不能用 == 。</p>
<h3 id="Q3：String-是不可变类为什么值可以修改？"><a href="#Q3：String-是不可变类为什么值可以修改？" class="headerlink" title="Q3：String 是不可变类为什么值可以修改？"></a>Q3：String 是不可变类为什么值可以修改？</h3><p>String 类和其存储数据的成员变量 value 字节数组都是 final 修饰的。对一个 String 对象的任何修改实际上都是创建一个新 String 对象，再引用该对象。只是修改 String 变量引用的对象，没有修改原 String 对象的内容。</p>
<h3 id="Q4：字符串拼接的方式有哪些？"><a href="#Q4：字符串拼接的方式有哪些？" class="headerlink" title="Q4：字符串拼接的方式有哪些？"></a>Q4：字符串拼接的方式有哪些？</h3><p>① 直接用 + ，底层用 StringBuilder 实现。只适用小数量，如果在循环中使用 + 拼接，相当于不断创建新的 StringBuilder 对象再转换成 String 对象，效率极差。</p>
<p>② 使用 String 的 concat 方法，该方法中使用 Arrays.copyOf 创建一个新的字符数组 buf 并将当前字符串 value 数组的值拷贝到 buf 中，buf 长度 = 当前字符串长度 + 拼接字符串长度。之后调用 getChars 方法使用 System.arraycopy 将拼接字符串的值也拷贝到 buf 数组，最后用 buf 作为构造参数 new 一个新的 String 对象返回。效率稍高于直接使用 +。</p>
<p>③ 使用 StringBuilder 或 StringBuffer，两者的 append 方法都继承自 AbstractStringBuilder，该方法首先使用 Arrays.copyOf 确定新的字符数组容量，再调用 getChars 方法使用 System.arraycopy 将新的值追加到数组中。StringBuilder 是 JDK5 引入的，效率高但线程不安全。StringBuffer 使用 synchronized 保证线程安全。</p>
<h3 id="Q5：String-a-“a”-new-String-“b”-创建了几个对象？"><a href="#Q5：String-a-“a”-new-String-“b”-创建了几个对象？" class="headerlink" title="Q5：String a = “a” + new String(“b”) 创建了几个对象？"></a>Q5：String a = “a” + new String(“b”) 创建了几个对象？</h3><p>常量和常量拼接仍是常量，结果在常量池，只要有变量参与拼接结果就是变量，存在堆。</p>
<p>使用字面量时只创建一个常量池中的常量，使用 new 时如果常量池中没有该值就会在常量池中新创建，再在堆中创建一个对象引用常量池中常量。因此 String a = “a” + new String(“b”) 会创建四个对象，常量池中的 a 和 b，堆中的 b 和堆中的 ab。</p>
<h2 id="面向对象-10"><a href="#面向对象-10" class="headerlink" title="面向对象 10"></a>面向对象 10</h2><h3 id="Q1：谈一谈你对面向对象的理解"><a href="#Q1：谈一谈你对面向对象的理解" class="headerlink" title="Q1：谈一谈你对面向对象的理解"></a>Q1：谈一谈你对面向对象的理解</h3><p>面向过程让计算机有步骤地顺序做一件事，是过程化思维，使用面向过程语言开发大型项目，软件复用和维护存在很大问题，模块之间耦合严重。面向对象相对面向过程更适合解决规模较大的问题，可以拆解问题复杂度，对现实事物进行抽象并映射为开发对象，更接近人的思维。</p>
<p>例如开门这个动作，面向过程是 open(Door door)，动宾结构，door 作为操作对象的参数传入方法，方法内定义开门的具体步骤。面向对象的方式首先会定义一个类 Door，抽象出门的属性（如尺寸、颜色）和行为（如 open 和 close），主谓结构。</p>
<p>面向过程代码松散，强调流程化解决问题。面向对象代码强调高内聚、低耦合，先抽象模型定义共性行为，再解决实际问题。</p>
<h3 id="Q2：面向对象的三大特性？"><a href="#Q2：面向对象的三大特性？" class="headerlink" title="Q2：面向对象的三大特性？"></a>Q2：面向对象的三大特性？</h3><p>封装是对象功能内聚的表现形式，在抽象基础上决定信息是否公开及公开等级，核心问题是以什么方式暴漏哪些信息。主要任务是对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口实现。封装使对象关系变得简单，降低了代码耦合度，方便维护。</p>
<p>迪米特原则就是对封装的要求，即 A 模块使用 B 模块的某接口行为，对 B 模块中除此行为外的其他信息知道得应尽可能少。不直接对 public 属性进行读取和修改而使用 getter/setter 方法是因为假设想在修改属性时进行权限控制、日志记录等操作，在直接访问属性的情况下无法实现。如果将 public 的属性和行为修改为 private 一般依赖模块都会报错，因此不知道使用哪种权限时应优先使用 private。</p>
<p>继承用来扩展一个类，子类可继承父类的部分属性和行为使模块具有复用性。继承是”is-a”关系，可使用里氏替换原则判断是否满足”is-a”关系，即任何父类出现的地方子类都可以出现。如果父类引用直接使用子类引用来代替且可以正确编译并执行，输出结果符合子类场景预期，那么说明两个类符合里氏替换原则。</p>
<p>多态以封装和继承为基础，根据运行时对象实际类型使同一行为具有不同表现形式。多态指在编译层面无法确定最终调用的方法体，在运行期由 JVM 动态绑定，调用合适的重写方法。由于重载属于静态绑定，本质上重载结果是完全不同的方法，因此多态一般专指重写。</p>
<h3 id="Q3：重载和重写的区别？"><a href="#Q3：重载和重写的区别？" class="headerlink" title="Q3：重载和重写的区别？"></a>Q3：重载和重写的区别？</h3><p>重载指方法名称相同，但参数类型个数不同，是行为水平方向不同实现。对编译器来说，方法名称和参数列表组成了一个唯一键，称为方法签名，JVM 通过方法签名决定调用哪种重载方法。不管继承关系如何复杂，重载在编译时可以根据规则知道调用哪种目标方法，因此属于静态绑定。</p>
<p>JVM 在重载方法中选择合适方法的顺序：① 精确匹配。② 基本数据类型自动转换成更大表示范围。③ 自动拆箱与装箱。④ 子类向上转型。⑤ 可变参数。</p>
<p>重写指子类实现接口或继承父类时，保持方法签名完全相同，实现不同方法体，是行为垂直方向不同实现。</p>
<p>元空间有一个方法表保存方法信息，如果子类重写了父类的方法，则方法表中的方法引用会指向子类实现。父类引用执行子类方法时无法调用子类存在而父类不存在的方法。</p>
<p>重写方法访问权限不能变小，返回类型和抛出的异常类型不能变大，必须加 @Override 。</p>
<h3 id="Q4：类之间有哪些关系？"><a href="#Q4：类之间有哪些关系？" class="headerlink" title="Q4：类之间有哪些关系？"></a>Q4：类之间有哪些关系？</h3><table>
<thead>
<tr>
<th>类关系</th>
<th>描述</th>
<th>权力强侧</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td>父子类之间的关系：is-a</td>
<td>父类</td>
<td>小狗继承于动物</td>
</tr>
<tr>
<td>实现</td>
<td>接口和实现类之间的关系：can-do</td>
<td>接口</td>
<td>小狗实现了狗叫接口</td>
</tr>
<tr>
<td>组合</td>
<td>比聚合更强的关系：contains-a</td>
<td>整体</td>
<td>头是身体的一部分</td>
</tr>
<tr>
<td>聚合</td>
<td>暂时组装的关系：has-a</td>
<td>组装方</td>
<td>小狗和绳子是暂时的聚合关系</td>
</tr>
<tr>
<td>依赖</td>
<td>一个类用到另一个：depends-a</td>
<td>被依赖方</td>
<td>人养小狗，人依赖于小狗</td>
</tr>
<tr>
<td>关联</td>
<td>平等的使用关系：links-a</td>
<td>平等</td>
<td>人使用卡消费，卡可以提取人的信息</td>
</tr>
<tr>
<td>### Q5：Object 类有哪些方法？</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>equals：检测对象是否相等，默认使用 == 比较对象引用，可以重写 equals 方法自定义比较规则。equals 方法规范：自反性、对称性、传递性、一致性、对于任何非空引用 x，x.equals(null) 返回 false。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>hashCode：散列码是由对象导出的一个整型值，没有规律，每个对象都有默认散列码，值由对象存储地址得出。字符串散列码由内容导出，值可能相同。为了在集合中正确使用，一般需要同时重写 equals 和 hashCode，要求 equals 相同 hashCode 必须相同，hashCode 相同 equals 未必相同，因此 hashCode 是对象相等的必要不充分条件。</p>
<p>toString：打印对象时默认的方法，如果没有重写打印的是表示对象值的一个字符串。</p>
<p>clone：clone 方法声明为 protected，类只能通过该方法克隆它自己的对象，如果希望其他类也能调用该方法必须定义该方法为 public。如果一个对象的类没有实现 Cloneable 接口，该对象调用 clone 方***抛出一个 CloneNotSupport 异常。默认的 clone 方法是浅拷贝，一般重写 clone 方法需要实现 Cloneable 接口并指定访问修饰符为 public。</p>
<p>finalize：确定一个对象死亡至少要经过两次标记，如果对象在可达性分析后发现没有与 GC Roots 连接的引用链会被第一次标记，随后进行一次筛选，条件是对象是否有必要执行 finalize 方法。假如对象没有重写该方法或方法已被虚拟机调用，都视为没有必要执行。如果有必要执行，对象会被放置在 F-Queue 队列，由一条低调度优先级的 Finalizer 线程去执行。虚拟机会触发该方法但不保证会结束，这是为了防止某个对象的 finalize 方法执行缓慢或发生死循环。只要对象在 finalize 方法中重新与引用链上的对象建立关联就会在第二次标记时被移出回收集合。由于运行代价高昂且无法保证调用顺序，在 JDK 9 被标记为过时方法，并不适合释放资源。</p>
<p>getClass：返回包含对象信息的类对象。</p>
<p>wait / notify / notifyAll：阻塞或唤醒持有该对象锁的线程。</p>
<h3 id="Q6：内部类的作用是什么，有哪些分类？"><a href="#Q6：内部类的作用是什么，有哪些分类？" class="headerlink" title="Q6：内部类的作用是什么，有哪些分类？"></a>Q6：内部类的作用是什么，有哪些分类？</h3><p>内部类可对同一包中其他类隐藏，内部类方法可以访问定义这个内部类的作用域中的数据，包括 private 数据。</p>
<p>内部类是一个编译器现象，与虚拟机无关。编译器会把内部类转换成常规的类文件，用 $ 分隔外部类名与内部类名，其中匿名内部类使用数字编号，虚拟机对此一无所知。</p>
<p>静态内部类： 属于外部类，只加载一次。作用域仅在包内，可通过 外部类名.内部类名 直接访问，类内只能访问外部类所有静态属性和方法。HashMap 的 Node 节点，ReentrantLock 中的 Sync 类，ArrayList 的 SubList 都是静态内部类。内部类中还可以定义内部类，如 ThreadLoacl 静态内部类 ThreadLoaclMap 中定义了内部类 Entry。</p>
<p>成员内部类： 属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可访问外部类的所有内容。</p>
<p>局部内部类： 定义在方法内，不能声明访问修饰符，只能定义实例成员变量和实例方法，作用范围仅在声明类的代码块中。</p>
<p>匿名内部类： 只用一次的没有名字的类，可以简化代码，创建的对象类型相当于 new 的类的子类类型。用于实现事件监听和其他回调。</p>
<h3 id="Q7：访问权限控制符有哪些？"><a href="#Q7：访问权限控制符有哪些？" class="headerlink" title="Q7：访问权限控制符有哪些？"></a>Q7：访问权限控制符有哪些？</h3><p>访问权限控制符    本类    包内    包外子类    任何地方<br>public    √    √    √    √<br>protected    √    √    √    ×<br>无    √    √    ×    ×<br>private    √    ×    ×    ×</p>
<h3 id="Q8：接口和抽象类的异同？"><a href="#Q8：接口和抽象类的异同？" class="headerlink" title="Q8：接口和抽象类的异同？"></a>Q8：接口和抽象类的异同？</h3><p>接口和抽象类对实体类进行更高层次的抽象，仅定义公共行为和特征。</p>
<p>语法维度    抽象类    接口<br>成员变量    无特殊要求    默认 public static final 常量<br>构造方法    有构造方法，不能实例化    没有构造方法，不能实例化<br>方法    抽象类可以没有抽象方法，但有抽象方法一定是抽象类。    默认 public abstract，JDK8 支持默认/静态方法，JDK9 支持私有方法。<br>继承    单继承    多继承</p>
<h3 id="Q9：接口和抽象类应该怎么选择？"><a href="#Q9：接口和抽象类应该怎么选择？" class="headerlink" title="Q9：接口和抽象类应该怎么选择？"></a>Q9：接口和抽象类应该怎么选择？</h3><p>抽象类体现 is-a 关系，接口体现 can-do 关系。与接口相比，抽象类通常是对同类事物相对具体的抽象。</p>
<p>抽象类是模板式设计，包含一组具体特征，例如某汽车，底盘、控制电路等是抽象出来的共同特征，但内饰、显示屏、座椅材质可以根据不同级别配置存在不同实现。</p>
<p>接口是契约式设计，是开放的，定义了方法名、参数、返回值、抛出的异常类型，谁都可以实现它，但必须遵守接口的约定。例如所有车辆都必须实现刹车这种强制规范。</p>
<p>接口是顶级类，抽象类在接口下面的第二层，对接口进行了组合，然后实现部分接口。当纠结定义接口和抽象类时，推荐定义为接口，遵循接口隔离原则，按维度划分成多个接口，再利用抽象类去实现这些，方便后续的扩展和重构。</p>
<p>例如 Plane 和 Bird 都有 fly 方法，应把 fly 定义为接口，而不是抽象类的抽象方法再继承，因为除了 fly 行为外 Plane 和 Bird 间很难再找到其他共同特征。</p>
<h3 id="Q10：子类初始化的顺序"><a href="#Q10：子类初始化的顺序" class="headerlink" title="Q10：子类初始化的顺序"></a>Q10：子类初始化的顺序</h3><p>① 父类静态代码块和静态变量。② 子类静态代码块和静态变量。③ 父类普通代码块和普通变量。④ 父类构造方法。⑤ 子类普通代码块和普通变量。⑥ 子类构造方法。</p>
<h2 id="集合-7"><a href="#集合-7" class="headerlink" title="集合 7"></a>集合 7</h2><h3 id="Q1：说一说-ArrayList"><a href="#Q1：说一说-ArrayList" class="headerlink" title="Q1：说一说 ArrayList"></a>Q1：说一说 ArrayList</h3><p>ArrayList 是容量可变的非线程安全列表，使用数组实现，集合扩容时会创建更大的数组，把原有数组复制到新数组。支持对元素的快速随机访问，但插入与删除速度很慢。ArrayList 实现了 RandomAcess 标记接口，如果一个类实现了该接口，那么表示使用索引遍历比迭代器更快。</p>
<p>elementData是 ArrayList 的数据域，被 transient 修饰，序列化时会调用 writeObject 写入流，反序列化时调用 readObject 重新赋值到新对象的 elementData。原因是 elementData 容量通常大于实际存储元素的数量，所以只需发送真正有实际值的数组元素。</p>
<p>size 是当前实际大小，elementData 大小大于等于 size。</p>
<p>*modCount *记录了 ArrayList 结构性变化的次数，继承自 AbstractList。所有涉及结构变化的方法都会增加该值。expectedModCount 是迭代器初始化时记录的 modCount 值，每次访问新元素时都会检查 modCount 和 expectedModCount 是否相等，不相等就会抛出异常。这种机制叫做 fail-fast，所有集合类都有这种机制。</p>
<h3 id="Q2：说一说-LinkedList"><a href="#Q2：说一说-LinkedList" class="headerlink" title="Q2：说一说 LinkedList"></a>Q2：说一说 LinkedList</h3><p>LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。除继承 AbstractList 外还实现了 Deque 接口，这个接口具有队列和栈的性质。成员变量被 transient 修饰，原理和 ArrayList 类似。</p>
<p>LinkedList 包含三个重要的成员：size、first 和 last。size 是双向链表中节点的个数，first 和 last 分别指向首尾节点的引用。</p>
<p>LinkedList 的优点在于可以将零散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存利用率较高。</p>
<h3 id="Q3：Set-有什么特点，有哪些实现？"><a href="#Q3：Set-有什么特点，有哪些实现？" class="headerlink" title="Q3：Set 有什么特点，有哪些实现？"></a>Q3：Set 有什么特点，有哪些实现？</h3><p>Set 不允许元素重复且无序，常用实现有 HashSet、LinkedHashSet 和 TreeSet。</p>
<p>HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，所有 Key 都使用相同的 Value ，一个名为 PRESENT 的 Object 类型常量。使用 Key 保证元素唯一性，但不保证有序性。由于 HashSet 是 HashMap 实现的，因此线程不安全。</p>
<p>HashSet 判断元素是否相同时，对于包装类型直接按值比较。对于引用类型先比较 hashCode 是否相同，不同则代表不是同一个对象，相同则继续比较 equals，都相同才是同一个对象。</p>
<p>LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。</p>
<p>TreeSet 通过 TreeMap 实现的，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。</p>
<h3 id="Q4：TreeMap-有什么特点？"><a href="#Q4：TreeMap-有什么特点？" class="headerlink" title="Q4：TreeMap 有什么特点？"></a>Q4：TreeMap 有什么特点？</h3><p>TreeMap 基于红黑树实现，增删改查的平均和最差时间复杂度均为 O(logn) ，最大特点是 Key 有序。Key 必须实现 Comparable 接口或提供的 Comparator 比较器，所以 Key 不允许为 null。</p>
<p>HashMap 依靠 hashCode 和 equals 去重，而 TreeMap 依靠 Comparable 或 Comparator。 TreeMap 排序时，如果比较器不为空就会优先使用比较器的 compare 方法，否则使用 Key 实现的 Comparable 的 compareTo 方法，两者都不满足会抛出异常。</p>
<p>TreeMap 通过 put 和 deleteEntry 实现增加和删除树节点。插入新节点的规则有三个：① 需要调整的新节点总是红色的。② 如果插入新节点的父节点是黑色的，不需要调整。③ 如果插入新节点的父节点是红色的，由于红黑树不能出现相邻红色，进入循环判断，通过重新着色或左右旋转来调整。TreeMap 的插入操作就是按照 Key 的对比往下遍历，大于节点值向右查找，小于向左查找，先按照二叉查找树的特性操作，后续会重新着色和旋转，保持红黑树的特性。</p>
<h3 id="Q5：HashMap-有什么特点？"><a href="#Q5：HashMap-有什么特点？" class="headerlink" title="Q5：HashMap 有什么特点？"></a>Q5：HashMap 有什么特点？</h3><p>JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树，节点类型从Entry 变更为 Node。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。</p>
<p>table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。</p>
<p>HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个链表上，为使查询效率尽可能高，键的 hash 值要尽可能分散。</p>
<p>HashMap 默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p>
<h3 id="Q6：HashMap-相关方法的源码？"><a href="#Q6：HashMap-相关方法的源码？" class="headerlink" title="Q6：HashMap 相关方法的源码？"></a>Q6：HashMap 相关方法的源码？</h3><p>JDK8 之前</p>
<p>hash：计算元素 key 的散列值</p>
<p>① 处理 String 类型时，调用 stringHash32 方法获取 hash 值。</p>
<p>② 处理其他类型数据时，提供一个相对于 HashMap 实例唯一不变的随机值 hashSeed 作为计算初始量。</p>
<p>③ 执行异或和无符号右移使 hash 值更加离散，减小哈希冲突概率。</p>
<p>indexFor：计算元素下标</p>
<p>将 hash 值和数组长度-1 进行与操作，保证结果不会超过 table 数组范围。</p>
<p>get：获取元素的 value 值</p>
<p>① 如果 key 为 null，调用 getForNullKey 方法，如果 size 为 0 表示链表为空，返回 null。如果 size 不为 0 说明存在链表，遍历 table[0] 链表，如果找到了 key 为 null 的节点则返回其 value，否则返回 null。</p>
<p>② 如果 key 为 不为 null，调用 getEntry 方法，如果 size 为 0 表示链表为空，返回 null 值。如果 size 不为 0，首先计算 key 的 hash 值，然后遍历该链表的所有节点，如果节点的 key 和 hash 值都和要查找的元素相同则返回其 Entry 节点。</p>
<p>③ 如果找到了对应的 Entry 节点，调用 getValue 方法获取其 value 并返回，否则返回 null。</p>
<p>put：添加元素</p>
<p>① 如果 key 为 null，直接存入 table[0]。</p>
<p>② 如果 key 不为 null，计算 key 的 hash 值。</p>
<p>③ 调用 indexFor 计算元素存放的下标 i。</p>
<p>④ 遍历 table[i] 对应的链表，如果 key 已存在，就更新 value 然后返回旧 value。</p>
<p>⑤ 如果 key 不存在，将 modCount 值加 1，使用 addEntry 方法增加一个节点并返回 null。</p>
<p>resize：扩容数组</p>
<p>① 如果当前容量达到了最大容量，将阈值设置为 Integer 最大值，之后扩容不再触发。</p>
<p>② 否则计算新的容量，将阈值设为 newCapacity x loadFactor 和 最大容量 + 1 的较小值。</p>
<p>③ 创建一个容量为 newCapacity 的 Entry 数组，调用 transfer 方法将旧数组的元素转移到新数组。</p>
<p>transfer：转移元素</p>
<p>① 遍历旧数组的所有元素，调用 rehash 方法判断是否需要哈希重构，如果需要就重新计算元素 key 的 hash 值。</p>
<p>② 调用 indexFor 方法计算元素存放的下标 i，利用头插法将旧数组的元素转移到新数组。</p>
<p>JDK8</p>
<p>hash：计算元素 key 的散列值</p>
<p>如果 key 为 null 返回 0，否则就将 key 的 hashCode 方法返回值高低16位异或，让尽可能多的位参与运算，让结果的 0 和 1 分布更加均匀，降低哈希冲突概率。</p>
<p>put：添加元素</p>
<p>① 调用 putVal 方法添加元素。</p>
<p>② 如果 table 为空或长度为 0 就进行扩容，否则计算元素下标位置，不存在就调用 newNode 创建一个节点。</p>
<p>③ 如果存在且是链表，如果首节点和待插入元素的 hash 和 key 都一样，更新节点的 value。</p>
<p>④ 如果首节点是 TreeNode 类型，调用 putTreeVal 方法增加一个树节点，每一次都比较插入节点和当前节点的大小，待插入节点小就往左子树查找，否则往右子树查找，找到空位后执行两个方法：balanceInsert 方法，插入节点并调整平衡、moveRootToFront 方法，由于调整平衡后根节点可能变化，需要重置根节点。</p>
<p>⑤ 如果都不满足，遍历链表，根据 hash 和 key 判断是否重复，决定更新 value 还是新增节点。如果遍历到了链表末尾则添加节点，如果达到建树阈值 7，还需要调用 treeifyBin 把链表重构为红黑树。</p>
<p>⑥ 存放元素后将 modCount 加 1，如果 ++size &gt; threshold ，调用 resize 扩容。</p>
<p>get ：获取元素的 value 值</p>
<p>① 调用 getNode 方法获取 Node 节点，如果不是 null 就返回其 value 值，否则返回 null。</p>
<p>② getNode 方法中如果数组不为空且存在元素，先比较第一个节点和要查找元素的 hash 和 key ，如果都相同则直接返回。</p>
<p>③ 如果第二个节点是 TreeNode 类型则调用 getTreeNode 方法进行查找，否则遍历链表根据 hash 和 key 查找，如果没有找到就返回 null。</p>
<p>resize：扩容数组</p>
<p>重新规划长度和阈值，如果长度发生了变化，部分数据节点也要重新排列。</p>
<p>重新规划长度</p>
<p>① 如果当前容量 oldCap &gt; 0 且达到最大容量，将阈值设为 Integer 最大值，return 终止扩容。</p>
<p>② 如果未达到最大容量，当 oldCap &lt;&lt; 1 不超过最大容量就扩大为 2 倍。</p>
<p>③ 如果都不满足且当前扩容阈值 oldThr &gt; 0，使用当前扩容阈值作为新容量。</p>
<p>④ 否则将新容量置为默认初始容量 16，新扩容阈值置为 12。</p>
<p>重新排列数据节点</p>
<p>① 如果节点为 null 不进行处理。</p>
<p>② 如果节点不为 null 且没有next节点，那么通过节点的 hash 值和 新容量-1 进行与运算计算下标存入新的 table 数组。</p>
<p>③ 如果节点为 TreeNode 类型，调用 split 方法处理，如果节点数 hc 达到6 会调用 untreeify 方法转回链表。</p>
<p>④ 如果是链表节点，需要将链表拆分为 hash 值超出旧容量的链表和未超出容量的链表。对于hash &amp; oldCap == 0 的部分不需要做处理，否则需要放到新的下标位置上，新下标 = 旧下标 + 旧容量。</p>
<h3 id="Q7：HashMap-为什么线程不安全？"><a href="#Q7：HashMap-为什么线程不安全？" class="headerlink" title="Q7：HashMap 为什么线程不安全？"></a>Q7：HashMap 为什么线程不安全？</h3><p>JDK7 存在死循环和数据丢失问题。</p>
<p>数据丢失：</p>
<p>并发赋值被覆盖： 在 createEntry 方法中，新添加的元素直接放在头部，使元素之后可以被更快访问，但如果两个线程同时执行到此处，会导致其中一个线程的赋值被覆盖。</p>
<p>已遍历区间新增元素丢失： 当某个线程在 transfer 方法迁移时，其他线程新增的元素可能落在已遍历过的哈希槽上。遍历完成后，table 数组引用指向了 newTable，新增元素丢失。</p>
<p>新表被覆盖： 如果 resize 完成，执行了 table = newTable，则后续元素就可以在新表上进行插入。但如果多线程同时 resize ，每个线程都会 new 一个数组，这是线程内的局部对象，线程之间不可见。迁移完成后resize 的线程会赋值给 table 线程共享变量，可能会覆盖其他线程的操作，在新表中插入的对象都会被丢弃。</p>
<p>死循环： 扩容时 resize 调用 transfer 使用头插法迁移元素，虽然 newTable 是局部变量，但原先 table 中的 Entry 链表是共享的，问题根源是 Entry 的 next 指针并发修改，某线程还没有将 table 设为 newTable 时用完了 CPU 时间片，导致数据丢失或死循环。</p>
<p>JDK8 在 resize 方法中完成扩容，并改用尾插法，不会产生死循环，但并发下仍可能丢失数据。可用 ConcurrentHashMap 或 Collections.synchronizedMap 包装成同步集合。</p>
<h2 id="IO-流-6"><a href="#IO-流-6" class="headerlink" title="IO 流 6"></a>IO 流 6</h2><h3 id="Q1：同步-异步-阻塞-非阻塞-IO-的区别？"><a href="#Q1：同步-异步-阻塞-非阻塞-IO-的区别？" class="headerlink" title="Q1：同步/异步/阻塞/非阻塞 IO 的区别？"></a>Q1：同步/异步/阻塞/非阻塞 IO 的区别？</h3><p>同步和异步是通信机制，阻塞和非阻塞是调用状态。</p>
<p>同步 IO 是用户线程发起 IO 请求后需要等待或轮询内核 IO 操作完成后才能继续执行。异步 IO 是用户线程发起 IO 请求后可以继续执行，当内核 IO 操作完成后会通知用户线程，或调用用户线程注册的回调函数。</p>
<p>阻塞 IO 是 IO 操作需要彻底完成后才能返回用户空间 。非阻塞 IO 是 IO 操作调用后立即返回一个状态值，无需等 IO 操作彻底完成。</p>
<h3 id="Q2：什么是-BIO？"><a href="#Q2：什么是-BIO？" class="headerlink" title="Q2：什么是 BIO？"></a>Q2：什么是 BIO？</h3><p>BIO 是同步阻塞式 IO，JDK1.4 之前的 IO 模型。服务器实现模式为一个连接请求对应一个线程，服务器需要为每一个客户端请求创建一个线程，如果这个连接不做任何事会造成不必要的线程开销。可以通过线程池改善，这种 IO 称为伪异步 IO。适用连接数目少且服务器资源多的场景。</p>
<h3 id="Q3：什么是-NIO？"><a href="#Q3：什么是-NIO？" class="headerlink" title="Q3：什么是 NIO？"></a>Q3：什么是 NIO？</h3><p>NIO 是 JDK1.4 引入的同步非阻塞 IO。服务器实现模式为多个连接请求对应一个线程，客户端连接请求会注册到一个多路复用器 Selector ，Selector 轮询到连接有 IO 请求时才启动一个线程处理。适用连接数目多且连接时间短的场景。</p>
<p>同步是指线程还是要不断接收客户端连接并处理数据，非阻塞是指如果一个管道没有数据，不需要等待，可以轮询下一个管道。</p>
<p>核心组件：</p>
<p>Selector： 多路复用器，轮询检查多个 Channel 的状态，判断注册事件是否发生，即判断 Channel 是否处于可读或可写状态。使用前需要将 Channel 注册到 Selector，注册后会得到一个 SelectionKey，通过 SelectionKey 获取 Channel 和 Selector 相关信息。</p>
<p>Channel： 双向通道，替换了 BIO 中的 Stream 流，不能直接访问数据，要通过 Buffer 来读写数据，也可以和其他 Channel 交互。</p>
<p>Buffer： 缓冲区，本质是一块可读写数据的内存，用来简化数据读写。Buffer 三个重要属性：position 下次读写数据的位置，limit 本次读写的极限位置，capacity 最大容量。</p>
<p>flip 将写转为读，底层实现原理把 position 置 0，并把 limit 设为当前的 position 值。<br>clear 将读转为写模式（用于读完全部数据的情况，把 position 置 0，limit 设为 capacity）。<br>compact 将读转为写模式（用于存在未读数据的情况，让 position 指向未读数据的下一个）。<br>通道方向和 Buffer 方向相反，读数据相当于向 Buffer 写，写数据相当于从 Buffer 读。<br>使用步骤：向 Buffer 写数据，调用 flip 方法转为读模式，从 Buffer 中读数据，调用 clear 或 compact 方法清空缓冲区。</p>
<h3 id="Q4：什么是-AIO？"><a href="#Q4：什么是-AIO？" class="headerlink" title="Q4：什么是 AIO？"></a>Q4：什么是 AIO？</h3><p>AIO 是 JDK7 引入的异步非阻塞 IO。服务器实现模式为一个有效请求对应一个线程，客户端的 IO 请求都是由操作系统先完成 IO 操作后再通知服务器应用来直接使用准备好的数据。适用连接数目多且连接时间长的场景。</p>
<p>异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情，非阻塞是指客户端有数据才会处理，处理好再通知服务器。</p>
<p>实现方式包括通过 Future 的 get 方法进行阻塞式调用以及实现 CompletionHandler 接口，重写请求成功的回调方法 completed 和请求失败回调方法 failed。</p>
<h3 id="Q5：java-io-包下有哪些流？"><a href="#Q5：java-io-包下有哪些流？" class="headerlink" title="Q5：java.io 包下有哪些流？"></a>Q5：java.io 包下有哪些流？</h3><p>主要分为字符流和字节流，字符流一般用于文本文件，字节流一般用于图像或其他文件。</p>
<p>字符流包括了字符输入流 Reader 和字符输出流 Writer，字节流包括了字节输入流 InputStream 和字节输出流 OutputStream。字符流和字节流都有对应的缓冲流，字节流也可以包装为字符流，缓冲流带有一个 8KB 的缓冲数组，可以提高流的读写效率。除了缓冲流外还有过滤流 FilterReader、字符数组流 CharArrayReader、字节数组流 ByteArrayInputStream、文件流 FileInputStream 等。</p>
<h3 id="Q6：序列化和反序列化是什么？"><a href="#Q6：序列化和反序列化是什么？" class="headerlink" title="Q6：序列化和反序列化是什么？"></a>Q6：序列化和反序列化是什么？</h3><p>Java 对象 JVM 退出时会全部销毁，如果需要将对象及状态持久化，就要通过序列化实现，将内存中的对象保存在二进制流中，需要时再将二进制流反序列化为对象。对象序列化保存的是对象的状态，因此属于类属性的静态变量不会被序列化。</p>
<p>常见的序列化有三种：</p>
<p>Java 原生序列化</p>
<p>实现 Serializabale 标记接口，Java 序列化保留了对象类的元数据（如类、成员变量、继承类信息）以及对象数据，兼容性最好，但不支持跨语言，性能一般。序列化和反序列化必须保持序列化 ID 的一致，一般使用 private static final long serialVersionUID 定义序列化 ID，如果不设置编译器会根据类的内部实现自动生成该值。如果是兼容升级不应该修改序列化 ID，防止出错，如果是不兼容升级则需要修改。</p>
<p>Hessian 序列化</p>
<p>Hessian 序列化是一种支持动态类型、跨语言、基于对象传输的网络协议。Java 对象序列化的二进制流可以被其它语言反序列化。Hessian 协议的特性：① 自描述序列化类型，不依赖外部描述文件，用一个字节表示常用基础类型，极大缩短二进制流。② 语言无关，支持脚本语言。③ 协议简单，比 Java 原生序列化高效。Hessian 会把复杂对象所有属性存储在一个 Map 中序列化，当父类和子类存在同名成员变量时会先序列化子类再序列化父类，因此子类值会被父类覆盖。</p>
<p>JSON 序列化</p>
<p>JSON 序列化就是将数据对象转换为 JSON 字符串，在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确进行。相比前两种方式可读性更好，方便调试。</p>
<p>序列化通常会使用网络传输对象，而对象中往往有敏感数据，容易遭受攻击，Jackson 和 fastjson 等都出现过反序列化漏洞，因此不需要进行序列化的敏感属性传输时应加上 transient 关键字。transient 的作用就是把变量生命周期仅限于内存而不会写到磁盘里持久化，变量会被设为对应数据类型的零值。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/18/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-基础-40"><span class="nav-number">1.</span> <span class="nav-text">Java 基础 40</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语言特性-12"><span class="nav-number">1.1.</span> <span class="nav-text">语言特性 12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1：Java-语言的优点？"><span class="nav-number">1.1.1.</span> <span class="nav-text">Q1：Java 语言的优点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2：Java-如何实现平台无关？"><span class="nav-number">1.1.2.</span> <span class="nav-text">Q2：Java 如何实现平台无关？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q3：JDK-和-JRE-的区别？"><span class="nav-number">1.1.3.</span> <span class="nav-text">Q3：JDK 和 JRE 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q4：Java-按值调用还是引用调用？"><span class="nav-number">1.1.4.</span> <span class="nav-text">Q4：Java 按值调用还是引用调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q5：浅拷贝和深拷贝的区别？"><span class="nav-number">1.1.5.</span> <span class="nav-text">Q5：浅拷贝和深拷贝的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q6：什么是反射？"><span class="nav-number">1.1.6.</span> <span class="nav-text">Q6：什么是反射？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q7：Class-类的作用？如何获取一个-Class-对象？"><span class="nav-number">1.1.7.</span> <span class="nav-text">Q7：Class 类的作用？如何获取一个 Class 对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q8：什么是注解？什么是元注解？"><span class="nav-number">1.1.8.</span> <span class="nav-text">Q8：什么是注解？什么是元注解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q9：什么是泛型，有什么作用？"><span class="nav-number">1.1.9.</span> <span class="nav-text">Q9：什么是泛型，有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q10：泛型擦除是什么？"><span class="nav-number">1.1.10.</span> <span class="nav-text">Q10：泛型擦除是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q11：JDK8-新特性有哪些？"><span class="nav-number">1.1.11.</span> <span class="nav-text">Q11：JDK8 新特性有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q12：异常有哪些分类？"><span class="nav-number">1.1.12.</span> <span class="nav-text">Q12：异常有哪些分类？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型-5"><span class="nav-number">1.2.</span> <span class="nav-text">数据类型 5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1：Java-有哪些基本数据类型？"><span class="nav-number">1.2.1.</span> <span class="nav-text">Q1：Java 有哪些基本数据类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2：自动装箱-拆箱是什么？"><span class="nav-number">1.2.2.</span> <span class="nav-text">Q2：自动装箱&#x2F;拆箱是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q3：String-是不可变类为什么值可以修改？"><span class="nav-number">1.2.3.</span> <span class="nav-text">Q3：String 是不可变类为什么值可以修改？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q4：字符串拼接的方式有哪些？"><span class="nav-number">1.2.4.</span> <span class="nav-text">Q4：字符串拼接的方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q5：String-a-“a”-new-String-“b”-创建了几个对象？"><span class="nav-number">1.2.5.</span> <span class="nav-text">Q5：String a &#x3D; “a” + new String(“b”) 创建了几个对象？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象-10"><span class="nav-number">1.3.</span> <span class="nav-text">面向对象 10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1：谈一谈你对面向对象的理解"><span class="nav-number">1.3.1.</span> <span class="nav-text">Q1：谈一谈你对面向对象的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2：面向对象的三大特性？"><span class="nav-number">1.3.2.</span> <span class="nav-text">Q2：面向对象的三大特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q3：重载和重写的区别？"><span class="nav-number">1.3.3.</span> <span class="nav-text">Q3：重载和重写的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q4：类之间有哪些关系？"><span class="nav-number">1.3.4.</span> <span class="nav-text">Q4：类之间有哪些关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q6：内部类的作用是什么，有哪些分类？"><span class="nav-number">1.3.5.</span> <span class="nav-text">Q6：内部类的作用是什么，有哪些分类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q7：访问权限控制符有哪些？"><span class="nav-number">1.3.6.</span> <span class="nav-text">Q7：访问权限控制符有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q8：接口和抽象类的异同？"><span class="nav-number">1.3.7.</span> <span class="nav-text">Q8：接口和抽象类的异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q9：接口和抽象类应该怎么选择？"><span class="nav-number">1.3.8.</span> <span class="nav-text">Q9：接口和抽象类应该怎么选择？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q10：子类初始化的顺序"><span class="nav-number">1.3.9.</span> <span class="nav-text">Q10：子类初始化的顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合-7"><span class="nav-number">1.4.</span> <span class="nav-text">集合 7</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1：说一说-ArrayList"><span class="nav-number">1.4.1.</span> <span class="nav-text">Q1：说一说 ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2：说一说-LinkedList"><span class="nav-number">1.4.2.</span> <span class="nav-text">Q2：说一说 LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q3：Set-有什么特点，有哪些实现？"><span class="nav-number">1.4.3.</span> <span class="nav-text">Q3：Set 有什么特点，有哪些实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q4：TreeMap-有什么特点？"><span class="nav-number">1.4.4.</span> <span class="nav-text">Q4：TreeMap 有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q5：HashMap-有什么特点？"><span class="nav-number">1.4.5.</span> <span class="nav-text">Q5：HashMap 有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q6：HashMap-相关方法的源码？"><span class="nav-number">1.4.6.</span> <span class="nav-text">Q6：HashMap 相关方法的源码？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q7：HashMap-为什么线程不安全？"><span class="nav-number">1.4.7.</span> <span class="nav-text">Q7：HashMap 为什么线程不安全？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-流-6"><span class="nav-number">1.5.</span> <span class="nav-text">IO 流 6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1：同步-异步-阻塞-非阻塞-IO-的区别？"><span class="nav-number">1.5.1.</span> <span class="nav-text">Q1：同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞 IO 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2：什么是-BIO？"><span class="nav-number">1.5.2.</span> <span class="nav-text">Q2：什么是 BIO？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q3：什么是-NIO？"><span class="nav-number">1.5.3.</span> <span class="nav-text">Q3：什么是 NIO？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q4：什么是-AIO？"><span class="nav-number">1.5.4.</span> <span class="nav-text">Q4：什么是 AIO？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q5：java-io-包下有哪些流？"><span class="nav-number">1.5.5.</span> <span class="nav-text">Q5：java.io 包下有哪些流？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q6：序列化和反序列化是什么？"><span class="nav-number">1.5.6.</span> <span class="nav-text">Q6：序列化和反序列化是什么？</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguangyu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liguangyu1995" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liguangyu1995" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguangyu</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
